{/* Auto-generated by scripts/mdx_snippets_gen.py. Do not edit manually. */}

export const PyBasicFts = "uri = \"data/sample-lancedb\"\ndb = lancedb.connect(uri)\n\ntable = db.create_table(\n    \"my_table_fts\",\n    data=[\n        {\"vector\": [3.1, 4.1], \"text\": \"Frodo was a happy puppy\"},\n        {\"vector\": [5.9, 26.5], \"text\": \"There are several kittens playing\"},\n    ],\n)\n\n# passing `use_tantivy=False` to use lance FTS index\n# `use_tantivy=True` by default\ntable.create_fts_index(\"text\", use_tantivy=False)\ntable.search(\"puppy\").limit(10).select([\"text\"]).to_list()\n# [{'text': 'Frodo was a happy puppy', '_score': 0.6931471824645996}]\n# ...\n";

export const PyBasicFtsAsync = "uri = \"data/sample-lancedb\"\nasync_db = await lancedb.connect_async(uri)\n\nasync_tbl = await async_db.create_table(\n    \"my_table_fts_async\",\n    data=[\n        {\"vector\": [3.1, 4.1], \"text\": \"Frodo was a happy puppy\"},\n        {\"vector\": [5.9, 26.5], \"text\": \"There are several kittens playing\"},\n    ],\n)\n\n# async API uses our native FTS algorithm\nawait async_tbl.create_index(\"text\", config=FTS())\nawait (await async_tbl.search(\"puppy\")).select([\"text\"]).limit(10).to_list()\n# [{'text': 'Frodo was a happy puppy', '_score': 0.6931471824645996}]\n# ...\n";

export const PyBasicHybridSearch = "data = [\n    {\"text\": \"rebel spaceships striking from a hidden base\"},\n    {\"text\": \"have won their first victory against the evil Galactic Empire\"},\n    {\"text\": \"during the battle rebel spies managed to steal secret plans\"},\n    {\"text\": \"to the Empire's ultimate weapon the Death Star\"},\n]\nuri = \"data/sample-lancedb\"\ndb = lancedb.connect(uri)\ntable = db.create_table(\"documents\", schema=Documents)\n# ingest docs with auto-vectorization\ntable.add(data)\n# Create a fts index before the hybrid search\ntable.create_fts_index(\"text\")\n# hybrid search with default re-ranker\ntable.search(\"flower moon\", query_type=\"hybrid\").to_pandas()\n";

export const PyBasicHybridSearchAsync = "uri = \"data/sample-lancedb\"\nasync_db = await lancedb.connect_async(uri)\ndata = [\n    {\"text\": \"rebel spaceships striking from a hidden base\"},\n    {\"text\": \"have won their first victory against the evil Galactic Empire\"},\n    {\"text\": \"during the battle rebel spies managed to steal secret plans\"},\n    {\"text\": \"to the Empire's ultimate weapon the Death Star\"},\n]\nasync_tbl = await async_db.create_table(\"documents_async\", schema=Documents)\n# ingest docs with auto-vectorization\nawait async_tbl.add(data)\n# Create a fts index before the hybrid search\nawait async_tbl.create_index(\"text\", config=FTS())\ntext_query = \"flower moon\"\n# hybrid search with default re-ranker\nawait (await async_tbl.search(\"flower moon\", query_type=\"hybrid\")).to_pandas()\n";

export const PyClassDefinition = "class Metadata(BaseModel):\n    source: str\n    timestamp: datetime\n\n\nclass Document(BaseModel):\n    content: str\n    meta: Metadata\n\n\nclass LanceSchema(LanceModel):\n    id: str\n    vector: Vector(1536)\n    payload: Document\n";

export const PyClassDocuments = "class Documents(LanceModel):\n    vector: Vector(embeddings.ndims()) = embeddings.VectorField()\n    text: str = embeddings.SourceField()\n";

export const PyCreateTableAsyncWithNestedSchema = "# Let's add 100 sample rows to our dataset\ndata = [\n    LanceSchema(\n        id=f\"id{i}\",\n        vector=np.random.randn(1536),\n        payload=Document(\n            content=f\"document{i}\",\n            meta=Metadata(source=f\"source{i % 10}\", timestamp=datetime.now()),\n        ),\n    )\n    for i in range(100)\n]\n\nasync_tbl = await async_db.create_table(\"documents_async\", data=data)\n";

export const PyCreateTableWithNestedSchema = "# Let's add 100 sample rows to our dataset\ndata = [\n    LanceSchema(\n        id=f\"id{i}\",\n        vector=np.random.randn(1536),\n        payload=Document(\n            content=f\"document{i}\",\n            meta=Metadata(source=f\"source{i % 10}\", timestamp=datetime.now()),\n        ),\n    )\n    for i in range(100)\n]\n\n# Synchronous client\ntbl = db.create_table(\"documents\", data=data)\n";

export const PyExhaustiveSearch = "uri = \"data/sample-lancedb\"\ndb = lancedb.connect(uri)\ndata = [\n    {\"vector\": row, \"item\": f\"item {i}\"}\n    for i, row in enumerate(np.random.random((10_000, 1536)).astype(\"float32\"))\n]\ntbl = db.create_table(\"vector_search\", data=data)\ntbl.search(np.random.random((1536))).limit(10).to_list()\n";

export const PyExhaustiveSearchAsync = "uri = \"data/sample-lancedb\"\nasync_db = await lancedb.connect_async(uri)\ndata = [\n    {\"vector\": row, \"item\": f\"item {i}\"}\n    for i, row in enumerate(np.random.random((10_000, 1536)).astype(\"float32\"))\n]\nasync_tbl = await async_db.create_table(\"vector_search_async\", data=data)\n(await (await async_tbl.search(np.random.random((1536)))).limit(10).to_list())\n";

export const PyExhaustiveSearchAsyncCosine = "(\n    await (await async_tbl.search(np.random.random((1536))))\n    .distance_type(\"cosine\")\n    .limit(10)\n    .to_list()\n)\n";

export const PyExhaustiveSearchCosine = "tbl.search(np.random.random((1536))).distance_type(\"cosine\").limit(10).to_list()\n";

export const PyFtsConfigFolding = "table.create_fts_index(\n    \"text\",\n    use_tantivy=False,\n    language=\"French\",\n    stem=True,\n    ascii_folding=True,\n    replace=True,\n)\n";

export const PyFtsConfigFoldingAsync = "await async_tbl.create_index(\n    \"text\", config=FTS(language=\"French\", stem=True, ascii_folding=True)\n)\n";

export const PyFtsConfigStem = "table.create_fts_index(\"text\", tokenizer_name=\"en_stem\", replace=True)\n";

export const PyFtsConfigStemAsync = "await async_tbl.create_index(\n    \"text\", config=FTS(language=\"English\", stem=True, remove_stop_words=True)\n)\n";

export const PyFtsIncrementalIndex = "table.add([{\"vector\": [3.1, 4.1], \"text\": \"Frodo was a happy puppy\"}])\ntable.optimize()\n";

export const PyFtsIncrementalIndexAsync = "await async_tbl.add([{\"vector\": [3.1, 4.1], \"text\": \"Frodo was a happy puppy\"}])\nawait async_tbl.optimize()\n";

export const PyFtsPostfiltering = "table.search(\"puppy\").limit(10).where(\"text='foo'\", prefilter=False).to_list()\n";

export const PyFtsPostfilteringAsync = "await (\n    (await async_tbl.search(\"puppy\"))\n    .limit(10)\n    .where(\"text='foo'\")\n    .postfilter()\n    .to_list()\n)\n";

export const PyFtsPrefiltering = "table.search(\"puppy\").limit(10).where(\"text='foo'\", prefilter=True).to_list()\n";

export const PyFtsPrefilteringAsync = "await (await async_tbl.search(\"puppy\")).limit(10).where(\"text='foo'\").to_list()\n";

export const PyFtsWithPosition = "table.create_fts_index(\"text\", use_tantivy=False, with_position=True, replace=True)\n";

export const PyFtsWithPositionAsync = "await async_tbl.create_index(\"text\", config=FTS(with_position=True))\n";

export const PyHybridSearchPassVectorText = "vector_query = [0.1, 0.2, 0.3, 0.4, 0.5]\ntext_query = \"flower moon\"\n(\n    table.search(query_type=\"hybrid\")\n    .vector(vector_query)\n    .text(text_query)\n    .limit(5)\n    .to_pandas()\n)\n";

export const PyHybridSearchPassVectorTextAsync = "vector_query = [0.1, 0.2, 0.3, 0.4, 0.5]\ntext_query = \"flower moon\"\nawait (\n    async_tbl.query()\n    .nearest_to(vector_query)\n    .nearest_to_text(text_query)\n    .limit(5)\n    .to_pandas()\n)\n";

export const PyImportDatetime = "from datetime import datetime\n";

export const PyImportEmbeddings = "from lancedb.embeddings import get_registry\n";

export const PyImportLancedb = "import lancedb\n";

export const PyImportLancedbFts = "from lancedb.index import FTS\n";

export const PyImportLancedbPydantic = "from lancedb.pydantic import Vector, LanceModel\n";

export const PyImportNumpy = "from lancedb.query import BoostQuery, MatchQuery\nimport numpy as np\nimport pyarrow as pa\n";

export const PyImportOpenai = "import openai\n";

export const PyImportOs = "import os\n";

export const PyImportPydanticBaseModel = "from pydantic import BaseModel\n";

export const PyOpenaiEmbeddings = "# Ingest embedding function in LanceDB table\n# Configuring the environment variable OPENAI_API_KEY\nif \"OPENAI_API_KEY\" not in os.environ:\n    # OR set the key here as a variable\n    openai.api_key = \"sk-...\"\nembeddings = get_registry().get(\"openai\").create()\n";

export const PySearchResultAsList = "tbl.search(np.random.randn(1536)).to_list()\n";

export const PySearchResultAsPandas = "tbl.search(np.random.randn(1536)).to_pandas()\n";

export const PySearchResultAsPandasFlatten1 = "tbl.search(np.random.randn(1536)).to_pandas(flatten=1)\n";

export const PySearchResultAsPandasFlattenTrue = "tbl.search(np.random.randn(1536)).to_pandas(flatten=True)\n";

export const PySearchResultAsPyarrow = "tbl.search(np.random.randn(1536)).to_arrow()\n";

export const PySearchResultAsPydantic = "tbl.search(np.random.randn(1536)).to_pydantic(LanceSchema)\n";

export const PySearchResultAsyncAsList = "await (await async_tbl.search(np.random.randn(1536))).to_list()\n";

export const PySearchResultAsyncAsPandas = "await (await async_tbl.search(np.random.randn(1536))).to_pandas()\n";

export const PySearchResultAsyncAsPyarrow = "await (await async_tbl.search(np.random.randn(1536))).to_arrow()\n";

export const TsDistanceRange = "const results3 = await (\n  tbl.search(Array(128).fill(1.2)) as lancedb.VectorQuery\n)\n  .distanceType(\"cosine\")\n  .distanceRange(0.1, 0.2)\n  .limit(10)\n  .toArray();\n";

export const TsImport = "import * as lancedb from \"@lancedb/lancedb\";\n";

export const TsImportBinUtil = "import { Field, FixedSizeList, Int32, Schema, Uint8 } from \"apache-arrow\";\n";

export const TsIngestBinaryData = "const schema = new Schema([\n  new Field(\"id\", new Int32(), true),\n  new Field(\"vec\", new FixedSizeList(32, new Field(\"item\", new Uint8()))),\n]);\nconst data = lancedb.makeArrowTable(\n  Array(1_000)\n    .fill(0)\n    .map((_, i) => ({\n      // the 256 bits would be store in 32 bytes,\n      // if your data is already in this format, you can skip the packBits step\n      id: i,\n      vec: lancedb.packBits(Array(256).fill(i % 2)),\n    })),\n  { schema: schema },\n);\n\nconst tbl = await db.createTable(\"binary_table\", data);\nawait tbl.createIndex(\"vec\", {\n  config: lancedb.Index.ivfFlat({\n    numPartitions: 10,\n    distanceType: \"hamming\",\n  }),\n});\n";

export const TsSearch1 = "const db = await lancedb.connect(databaseDir);\nconst tbl = await db.openTable(\"my_vectors\");\n\nconst results1 = await tbl.search(Array(128).fill(1.2)).limit(10).toArray();\n";

export const TsSearch2 = "const results2 = await (\n  tbl.search(Array(128).fill(1.2)) as lancedb.VectorQuery\n)\n  .distanceType(\"cosine\")\n  .limit(10)\n  .toArray();\n";

export const TsSearchBinaryData = "const query = Array(32)\n  .fill(1)\n  .map(() => Math.floor(Math.random() * 255));\nconst results = await tbl.query().nearestTo(query).limit(10).toArrow();\n";

