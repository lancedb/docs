---
title: "Scalar Indexes in LanceDB"
sidebarTitle: "Scalar Index"
description: "Use scalar indexes for efficient metadata filtering and hybrid searches."
weight: 3
aliases:
  - "/docs/concepts/indexing/scalar-index/"
  - "/docs/concepts/indexing/scalar-index"
---
import {
    PyScalarIndexBuild as ScalarIndexBuild,
    PyScalarIndexWait as ScalarIndexWait,
    PyScalarIndexOptimize as ScalarIndexOptimize,
    PyScalarIndexFilter as ScalarIndexFilter,
    PyScalarIndexPrefilter as ScalarIndexPrefilter,
    PyScalarIndexUuidType as ScalarIndexUuidType,
    PyScalarIndexUuidData as ScalarIndexUuidData,
    PyScalarIndexUuidTable as ScalarIndexUuidTable,
    PyScalarIndexUuidWait as ScalarIndexUuidWait,
    PyScalarIndexUuidUpsert as ScalarIndexUuidUpsert,
} from '/snippets/indexing.mdx';

Scalar indexes organize scalar attributes (numbers, categories, timestamps) to accelerate filtering alongside vector data.

Supported scalar index types:

- `BTREE`: sorted values for binary search—best for high-cardinality columns.
- `BITMAP`: tracks value presence—ideal for low-cardinality columns.
- `LABEL_LIST`: optimized for `array_contains_any` / `array_contains_all` on `List<T>` columns.

## Choosing the Right Index Type

| Data Type | Filter | Index Type |
|:----------|:-------|:-----------|
| Numeric, string, temporal | `<`, `=`, `>`, `IN`, `BETWEEN`, `IS NULL` | `BTREE` |
| Boolean or low-cardinality strings/numbers | `<`, `=`, `>`, `IN`, `BETWEEN`, `IS NULL` | `BITMAP` |
| Low-cardinality lists | `array_has_any`, `array_has_all` | `LABEL_LIST` |

## Scalar Index Operations

### 1. Build the Index

<CodeGroup>
    <CodeBlock filename="Python" language="Python" icon="Python">
    {ScalarIndexBuild}
    </CodeBlock>
</CodeGroup>

<Note title="LanceDB Cloud & Enterprise">
`create_scalar_index` returns immediately. Call `wait_for_index()` to block until indexing completes.
</Note>

### 2. Check Index Status

<CodeGroup>
    <CodeBlock filename="Python" language="Python" icon="Python">
    {ScalarIndexWait}
    </CodeBlock>
</CodeGroup>

### 3. Update the Index

Update scalar indexes after inserts/deletes by calling `optimize()`.

<CodeGroup>
    <CodeBlock filename="Python" language="Python" icon="Python">
    {ScalarIndexOptimize}
    </CodeBlock>
</CodeGroup>

<Note title="LanceDB Cloud">
Cloud automates `optimize`, so new data remains queryable without extra steps.
</Note>

### 4. Run Indexed Searches

Scalar indexes speed up pure scalar filters:

<CodeGroup>
    <CodeBlock filename="Python" language="Python" icon="Python">
    {ScalarIndexFilter}
    </CodeBlock>
</CodeGroup>

They also accelerate hybrid searches that combine vector similarity with scalar prefilters:

<CodeGroup>
    <CodeBlock filename="Python" language="Python" icon="Python">
    {ScalarIndexPrefilter}
    </CodeBlock>
</CodeGroup>

## Advanced: Index UUID Columns

LanceDB supports scalar indexes on UUID columns stored as `FixedSizeBinary(16)`, enabling efficient primary-key lookups.

<Note title="FixedSizeBinary requirements">
- Python SDK ≥ `0.22.0-beta.4`
- TypeScript SDK ≥ `0.19.0-beta.4`
</Note>

### 1. Define UUID Type

<CodeGroup>
    <CodeBlock filename="Python" language="Python" icon="Python">
    {ScalarIndexUuidType}
    </CodeBlock>
</CodeGroup>

### 2. Generate UUID Data

<CodeGroup>
    <CodeBlock filename="Python" language="Python" icon="Python">
    {ScalarIndexUuidData}
    </CodeBlock>
</CodeGroup>

### 3. Create Table with UUID Column

<CodeGroup>
    <CodeBlock filename="Python" language="Python" icon="Python">
    {ScalarIndexUuidTable}
    </CodeBlock>
</CodeGroup>

### 4. Create and Wait for the Index

<CodeGroup>
    <CodeBlock filename="Python" language="Python" icon="Python">
    {ScalarIndexUuidWait}
    </CodeBlock>
</CodeGroup>

### 5. Perform Operations with the UUID Index

<CodeGroup>
    <CodeBlock filename="Python" language="Python" icon="Python">
    {ScalarIndexUuidUpsert}
    </CodeBlock>
</CodeGroup>

