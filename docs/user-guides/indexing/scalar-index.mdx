---
title: "Scalar Indexes in LanceDB"
sidebarTitle: "Scalar Index"
description: "Use scalar indexes for efficient metadata filtering and hybrid searches."
weight: 3
aliases:
  - "/docs/concepts/indexing/scalar-index/"
  - "/docs/concepts/indexing/scalar-index"
---
import ScalarIndexBuild from '/snippets/py/scalar_index_build.mdx';
import ScalarIndexWait from '/snippets/py/scalar_index_wait.mdx';
import ScalarIndexOptimize from '/snippets/py/scalar_index_optimize.mdx';
import ScalarIndexFilter from '/snippets/py/scalar_index_filter.mdx';
import ScalarIndexPrefilter from '/snippets/py/scalar_index_prefilter.mdx';
import ScalarIndexUuidType from '/snippets/py/scalar_index_uuid_type.mdx';
import ScalarIndexUuidData from '/snippets/py/scalar_index_uuid_data.mdx';
import ScalarIndexUuidTable from '/snippets/py/scalar_index_uuid_table.mdx';
import ScalarIndexUuidWait from '/snippets/py/scalar_index_uuid_wait.mdx';
import ScalarIndexUuidUpsert from '/snippets/py/scalar_index_uuid_upsert.mdx';

Scalar indexes organize scalar attributes (numbers, categories, timestamps) to accelerate filtering alongside vector data.

Supported scalar index types:

- `BTREE`: sorted values for binary search—best for high-cardinality columns.
- `BITMAP`: tracks value presence—ideal for low-cardinality columns.
- `LABEL_LIST`: optimized for `array_contains_any` / `array_contains_all` on `List<T>` columns.

## Choosing the Right Index Type

| Data Type | Filter | Index Type |
|:----------|:-------|:-----------|
| Numeric, string, temporal | `<`, `=`, `>`, `IN`, `BETWEEN`, `IS NULL` | `BTREE` |
| Boolean or low-cardinality strings/numbers | `<`, `=`, `>`, `IN`, `BETWEEN`, `IS NULL` | `BITMAP` |
| Low-cardinality lists | `array_has_any`, `array_has_all` | `LABEL_LIST` |

## Scalar Index Operations

### 1. Build the Index

<CodeGroup>
  <ScalarIndexBuild />
</CodeGroup>

<Note title="LanceDB Cloud & Enterprise">
`create_scalar_index` returns immediately. Call `wait_for_index()` to block until indexing completes.
</Note>

### 2. Check Index Status

<CodeGroup>
  <ScalarIndexWait />
</CodeGroup>

### 3. Update the Index

Update scalar indexes after inserts/deletes by calling `optimize()`.

<CodeGroup>
  <ScalarIndexOptimize />
</CodeGroup>

<Note title="LanceDB Cloud">
Cloud automates `optimize`, so new data remains queryable without extra steps.
</Note>

### 4. Run Indexed Searches

Scalar indexes speed up pure scalar filters:

<CodeGroup>
  <ScalarIndexFilter />
</CodeGroup>

They also accelerate hybrid searches that combine vector similarity with scalar prefilters:

<CodeGroup>
  <ScalarIndexPrefilter />
</CodeGroup>

## Advanced: Index UUID Columns

LanceDB supports scalar indexes on UUID columns stored as `FixedSizeBinary(16)`, enabling efficient primary-key lookups.

<Note title="FixedSizeBinary requirements">
- Python SDK ≥ `0.22.0-beta.4`
- TypeScript SDK ≥ `0.19.0-beta.4`
</Note>

### 1. Define UUID Type

<CodeGroup>
  <ScalarIndexUuidType />
</CodeGroup>

### 2. Generate UUID Data

<CodeGroup>
  <ScalarIndexUuidData />
</CodeGroup>

### 3. Create Table with UUID Column

<CodeGroup>
  <ScalarIndexUuidTable />
</CodeGroup>

### 4. Create and Wait for the Index

<CodeGroup>
  <ScalarIndexUuidWait />
</CodeGroup>

### 5. Perform Operations with the UUID Index

<CodeGroup>
  <ScalarIndexUuidUpsert />
</CodeGroup>

